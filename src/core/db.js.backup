/**
 * Database Core - SQLite3 Otimizado para Alta Performance
 * Sistema de banco de dados do bot de volleyball com configuraÃ§Ãµes de performance crÃ­ticas
 * 
 * @author Volleyball Team
 * @version 3.0 - Completamente otimizado e moderno
 */

const Database = require('better-sqlite3');
const path = require('path');
const fs = require('fs');
const logger = require('../utils/logger');

// ===== CONFIGURAÃ‡ÃƒO DE CAMINHOS =====
const DATA_DIR = path.join(__dirname, '../../data');
const DB_PATH = path.join(DATA_DIR, 'volleyball.db');

// Garantir que o diretÃ³rio existe
if (!fs.existsSync(DATA_DIR)) {
  fs.mkdirSync(DATA_DIR, { recursive: true });
  logger.info('ðŸ“ DiretÃ³rio de dados criado:', DATA_DIR);
}

// ===== INICIALIZAÃ‡ÃƒO DO BANCO =====
logger.info('ðŸ—„ï¸ Inicializando banco SQLite...');
const db = new Database(DB_PATH);

// ===== CONFIGURAÃ‡Ã•ES CRÃTICAS DE PERFORMANCE =====
// Estas configuraÃ§Ãµes sÃ£o ESSENCIAIS para velocidade
try {
  logger.info('âš¡ Aplicando configuraÃ§Ãµes de alta performance...');
  
  // Write-Ahead Logging - CRÃTICO para performance em produÃ§Ã£o
  db.pragma('journal_mode = WAL');
  
  // ConfiguraÃ§Ãµes de sincronizaÃ§Ã£o otimizadas
  db.pragma('synchronous = NORMAL');       // Reduz sincronizaÃ§Ãµes de disco
  db.pragma('cache_size = -64000');        // Cache de 64MB em memÃ³ria
  db.pragma('temp_store = MEMORY');        // Tabelas temporÃ¡rias em RAM
  db.pragma('mmap_size = 268435456');      // Memory-mapped I/O de 256MB
  db.pragma('page_size = 4096');           // Tamanho de pÃ¡gina otimizado
  
  // ConfiguraÃ§Ãµes adicionais de performance
  db.pragma('foreign_keys = ON');          // Integridade referencial
  db.pragma('auto_vacuum = INCREMENTAL');  // Vacuum automÃ¡tico incremental
  db.pragma('wal_autocheckpoint = 1000');  // Checkpoint automÃ¡tico
  
  logger.success('âœ… ConfiguraÃ§Ãµes de performance aplicadas!');
  
} catch (error) {
  logger.error('âŒ Erro ao aplicar configuraÃ§Ãµes:', error.message);
  throw error;
}

// ===== MIGRATIONS E ESTRUTURA DO BANCO =====

/**
 * Executa as migrations do banco de dados
 * Cria todas as tabelas necessÃ¡rias com estrutura otimizada
 */
function runMigrations() {
  logger.info('ðŸ”„ Executando migrations...');
  
  try {
    // ========== TABELA DE USUÃRIOS ==========
    db.exec(`
      CREATE TABLE IF NOT EXISTS usuarios (
        id TEXT PRIMARY KEY,                    -- ID do WhatsApp (ex: 5519999999999@c.us)
        name TEXT,                              -- Nome atual do usuÃ¡rio
        phone TEXT,                             -- NÃºmero do telefone
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
      )
    `);
    
    // ========== TABELA DE GRUPOS ==========
    db.exec(`
      CREATE TABLE IF NOT EXISTS grupos (
        id TEXT PRIMARY KEY,                    -- ID do grupo (ex: 123456789@g.us)
        name TEXT NOT NULL,                     -- Nome do grupo
        description TEXT,                       -- DescriÃ§Ã£o do grupo
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
      )
    `);
    
    // ========== TABELA DE ADMINISTRADORES POR GRUPO ==========
    db.exec(`
      CREATE TABLE IF NOT EXISTS admins_grupos (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        grupo_id TEXT NOT NULL,                 -- ID do grupo
        usuario_id TEXT NOT NULL,               -- ID do usuÃ¡rio admin
        granted_by TEXT,                        -- Quem concedeu a permissÃ£o
        granted_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(grupo_id, usuario_id),           -- Evita duplicatas
        FOREIGN KEY (grupo_id) REFERENCES grupos(id) ON DELETE CASCADE,
        FOREIGN KEY (usuario_id) REFERENCES usuarios(id) ON DELETE CASCADE
      )
    `);
    
    // ========== TABELA DE PERMISSÃ•ES ESPECIAIS ==========
    db.exec(`
      CREATE TABLE IF NOT EXISTS permissoes_especiais (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        grupo_id TEXT NOT NULL,                 -- ID do grupo
        usuario_id TEXT NOT NULL,               -- ID do usuÃ¡rio
        comando TEXT NOT NULL,                  -- Comando especÃ­fico (ex: !kick)
        permitido BOOLEAN DEFAULT 1,           -- 1 = permitido, 0 = negado
        granted_by TEXT,                        -- Quem concedeu
        granted_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        expires_at DATETIME,                    -- Data de expiraÃ§Ã£o (opcional)
        UNIQUE(grupo_id, usuario_id, comando),  -- Uma permissÃ£o por comando por usuÃ¡rio
        FOREIGN KEY (grupo_id) REFERENCES grupos(id) ON DELETE CASCADE,
        FOREIGN KEY (usuario_id) REFERENCES usuarios(id) ON DELETE CASCADE
      )
    `);
    
    // ========== TABELA DE APELIDOS ==========
    db.exec(`
      CREATE TABLE IF NOT EXISTS apelidos (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        grupo_id TEXT NOT NULL,                 -- ID do grupo
        usuario_id TEXT NOT NULL,               -- ID do usuÃ¡rio
        nickname TEXT NOT NULL,                 -- Apelido do usuÃ¡rio
        set_by TEXT,                            -- Quem definiu o apelido
        locked BOOLEAN DEFAULT 0,              -- Se estÃ¡ bloqueado (1) ou nÃ£o (0)
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(grupo_id, usuario_id),           -- Um apelido por usuÃ¡rio por grupo
        FOREIGN KEY (grupo_id) REFERENCES grupos(id) ON DELETE CASCADE,
        FOREIGN KEY (usuario_id) REFERENCES usuarios(id) ON DELETE CASCADE
      )
    `);
    
    // ========== TABELA DE SILENCIAMENTO ==========
    db.exec(`
      CREATE TABLE IF NOT EXISTS silenciados (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        grupo_id TEXT NOT NULL,                 -- ID do grupo
        usuario_id TEXT NOT NULL,               -- ID do usuÃ¡rio silenciado
        silenciado_por TEXT,                    -- Quem aplicou o silenciamento
        motivo TEXT,                            -- Motivo do silenciamento
        minutos INTEGER,                        -- DuraÃ§Ã£o em minutos (NULL = permanente)
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        expires_at DATETIME,                    -- Data/hora de expiraÃ§Ã£o
        UNIQUE(grupo_id, usuario_id),           -- Um silenciamento por usuÃ¡rio por grupo
        FOREIGN KEY (grupo_id) REFERENCES grupos(id) ON DELETE CASCADE,
        FOREIGN KEY (usuario_id) REFERENCES usuarios(id) ON DELETE CASCADE
      )
    `);
    
    // ========== TABELA DE AUDITORIA ==========
    db.exec(`
      CREATE TABLE IF NOT EXISTS auditoria (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        usuario_id TEXT NOT NULL,               -- Quem executou
        grupo_id TEXT,                          -- Em que grupo (NULL = privado)
        comando TEXT NOT NULL,                  -- Comando executado
        argumentos TEXT,                        -- Argumentos do comando
        sucesso BOOLEAN DEFAULT 1,             -- Se foi executado com sucesso
        erro TEXT,                              -- Mensagem de erro (se houver)
        timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (usuario_id) REFERENCES usuarios(id) ON DELETE CASCADE,
        FOREIGN KEY (grupo_id) REFERENCES grupos(id) ON DELETE CASCADE
      )
    `);
    
    logger.success('âœ… Todas as tabelas criadas/verificadas com sucesso!');
    
  } catch (error) {
    logger.error('âŒ Erro durante migrations:', error.message);
    throw error;
  }
}

/**
 * Cria Ã­ndices otimizados para performance
 * Estes Ã­ndices sÃ£o CRÃTICOS para velocidade das consultas
 */
function createOptimizedIndexes() {
  logger.info('ðŸš€ Criando Ã­ndices de performance...');
  
  try {
    // ===== ÃNDICES PARA USUÃRIOS =====
    db.exec(`CREATE INDEX IF NOT EXISTS idx_usuarios_phone ON usuarios(phone)`);
    
    // ===== ÃNDICES PARA GRUPOS =====
    db.exec(`CREATE INDEX IF NOT EXISTS idx_grupos_name ON grupos(name)`);
    
    // ===== ÃNDICES CRÃTICOS PARA ADMINS =====
    // Este Ã© o mais importante - usado em TODAS as verificaÃ§Ãµes de permissÃ£o
    db.exec(`CREATE INDEX IF NOT EXISTS idx_admins_lookup 
             ON admins_grupos(grupo_id, usuario_id)`);
    db.exec(`CREATE INDEX IF NOT EXISTS idx_admins_granted_at 
             ON admins_grupos(granted_at)`);
    
    // ===== ÃNDICES PARA PERMISSÃ•ES ESPECIAIS =====
    db.exec(`CREATE INDEX IF NOT EXISTS idx_permissions_lookup 
             ON permissoes_especiais(grupo_id, usuario_id, comando)`);
    db.exec(`CREATE INDEX IF NOT EXISTS idx_permissions_expires 
             ON permissoes_especiais(expires_at) 
             WHERE expires_at IS NOT NULL`);
    
    // ===== ÃNDICES CRÃTICOS PARA APELIDOS =====
    // Usado constantemente nos comandos de apelido
    db.exec(`CREATE INDEX IF NOT EXISTS idx_apelidos_lookup 
             ON apelidos(grupo_id, usuario_id)`);
    db.exec(`CREATE INDEX IF NOT EXISTS idx_apelidos_nickname_unique 
             ON apelidos(grupo_id, LOWER(nickname))`);
    db.exec(`CREATE INDEX IF NOT EXISTS idx_apelidos_locked 
             ON apelidos(locked) WHERE locked = 1`);
    
    // ===== ÃNDICES PARA SILENCIAMENTO =====
    db.exec(`CREATE INDEX IF NOT EXISTS idx_silenciados_active 
             ON silenciados(grupo_id, usuario_id, expires_at)`);
    db.exec(`CREATE INDEX IF NOT EXISTS idx_silenciados_expires 
             ON silenciados(expires_at) 
             WHERE expires_at IS NOT NULL`);
    
    // ===== ÃNDICES PARA AUDITORIA =====
    db.exec(`CREATE INDEX IF NOT EXISTS idx_auditoria_usuario_comando 
             ON auditoria(usuario_id, comando)`);
    db.exec(`CREATE INDEX IF NOT EXISTS idx_auditoria_timestamp 
             ON auditoria(timestamp)`);
    db.exec(`CREATE INDEX IF NOT EXISTS idx_auditoria_grupo_timestamp 
             ON auditoria(grupo_id, timestamp)`);
    
    logger.success('âœ… Ãndices de performance criados!');
    
  } catch (error) {
    logger.warn('âš ï¸ Alguns Ã­ndices jÃ¡ existem:', error.message);
  }
}

// ===== PREPARED STATEMENTS OTIMIZADOS =====
// Todas as consultas sÃ£o prÃ©-compiladas para mÃ¡xima performance

const statements = {
  // ========== USUÃRIOS ==========
  insertUser: db.prepare(`
    INSERT OR REPLACE INTO usuarios (id, name, phone, updated_at) 
    VALUES (?, ?, ?, CURRENT_TIMESTAMP)
  `),
  
  getUser: db.prepare(`
    SELECT * FROM usuarios WHERE id = ? LIMIT 1
  `),
  
  getUserByPhone: db.prepare(`
    SELECT * FROM usuarios WHERE phone = ? LIMIT 1
  `),
  
  // ========== GRUPOS ==========
  insertGroup: db.prepare(`
    INSERT OR REPLACE INTO grupos (id, name, description, updated_at) 
    VALUES (?, ?, ?, CURRENT_TIMESTAMP)
  `),
  
  getGroup: db.prepare(`
    SELECT * FROM grupos WHERE id = ? LIMIT 1
  `),
  
  // ========== ADMINISTRADORES (CRÃTICO) ==========
  // Esta Ã© a consulta mais importante - otimizada ao mÃ¡ximo
  isGroupAdmin: db.prepare(`
    SELECT 1 FROM admins_grupos 
    WHERE grupo_id = ? AND usuario_id = ? 
    LIMIT 1
  `),
  
  addGroupAdmin: db.prepare(`
    INSERT OR REPLACE INTO admins_grupos (grupo_id, usuario_id, granted_by) 
    VALUES (?, ?, ?)
  `),
  
  removeGroupAdmin: db.prepare(`
    DELETE FROM admins_grupos 
    WHERE grupo_id = ? AND usuario_id = ?
  `),
  
  getAllGroupAdmins: db.prepare(`
    SELECT ag.usuario_id, ag.granted_by, ag.granted_at, u.name 
    FROM admins_grupos ag
    LEFT JOIN usuarios u ON ag.usuario_id = u.id
    WHERE ag.grupo_id = ?
    ORDER BY 
      CASE WHEN ag.usuario_id = ? THEN 0 ELSE 1 END,
      ag.granted_at ASC
  `),
  
  // ========== PERMISSÃ•ES ESPECIAIS ==========
  hasSpecialPermission: db.prepare(`
    SELECT permitido FROM permissoes_especiais 
    WHERE grupo_id = ? AND usuario_id = ? AND comando = ? 
    AND (expires_at IS NULL OR expires_at > CURRENT_TIMESTAMP)
    LIMIT 1
  `),
  
  grantSpecialPermission: db.prepare(`
    INSERT OR REPLACE INTO permissoes_especiais 
    (grupo_id, usuario_id, comando, permitido, granted_by, expires_at) 
    VALUES (?, ?, ?, ?, ?, ?)
  `),
  
  revokeSpecialPermission: db.prepare(`
    DELETE FROM permissoes_especiais 
    WHERE grupo_id = ? AND usuario_id = ? AND comando = ?
  `),
  
  // ========== APELIDOS (CRÃTICO) ==========
  // Otimizado para o sistema de apelidos mais usado
  getNickname: db.prepare(`
    SELECT nickname, locked, created_at, updated_at, set_by 
    FROM apelidos 
    WHERE grupo_id = ? AND usuario_id = ? 
    LIMIT 1
  `),
  
  setNickname: db.prepare(`
    INSERT OR REPLACE INTO apelidos 
    (grupo_id, usuario_id, nickname, set_by, locked, updated_at) 
    VALUES (?, ?, ?, ?, 
      COALESCE((SELECT locked FROM apelidos WHERE grupo_id = ? AND usuario_id = ?), 0),
      CURRENT_TIMESTAMP
    )
  `),
  
  isNicknameInUse: db.prepare(`
    SELECT 1 FROM apelidos 
    WHERE grupo_id = ? AND LOWER(nickname) = LOWER(?) AND usuario_id != ? 
    LIMIT 1
  `),
  
  lockNickname: db.prepare(`
    UPDATE apelidos 
    SET locked = ?, updated_at = CURRENT_TIMESTAMP 
    WHERE grupo_id = ? AND usuario_id = ?
  `),
  
  getAllNicknamesInGroup: db.prepare(`
    SELECT a.usuario_id, a.nickname, a.locked, a.created_at, a.updated_at,
           u.name as usuario_nome, set_by.name as definido_por_nome
    FROM apelidos a
    LEFT JOIN usuarios u ON a.usuario_id = u.id
    LEFT JOIN usuarios set_by ON a.set_by = set_by.id
    WHERE a.grupo_id = ?
    ORDER BY LOWER(a.nickname) COLLATE NOCASE
  `),
  
  // ========== SILENCIAMENTO ==========
  isSilenced: db.prepare(`
    SELECT 1 FROM silenciados 
    WHERE grupo_id = ? AND usuario_id = ? 
    AND (expires_at IS NULL OR expires_at > datetime('now'))
    LIMIT 1
  `),
  
  addSilenced: db.prepare(`
    INSERT OR REPLACE INTO silenciados 
    (grupo_id, usuario_id, silenciado_por, motivo, minutos, expires_at) 
    VALUES (?, ?, ?, ?, ?, ?)
  `),
  
  removeSilenced: db.prepare(`
    DELETE FROM silenciados 
    WHERE grupo_id = ? AND usuario_id = ?
  `),
  
  getSilenced: db.prepare(`
    SELECT * FROM silenciados 
    WHERE grupo_id = ? AND usuario_id = ? 
    AND (expires_at IS NULL OR expires_at > datetime('now'))
    LIMIT 1
  `),
  
  getAllSilencedInGroup: db.prepare(`
    SELECT s.*, u.name as usuario_nome 
    FROM silenciados s 
    LEFT JOIN usuarios u ON s.usuario_id = u.id 
    WHERE s.grupo_id = ? 
    AND (s.expires_at IS NULL OR s.expires_at > datetime('now'))
    ORDER BY s.created_at DESC
  `),
  
  removeAllSilencedInGroup: db.prepare(`
    DELETE FROM silenciados WHERE grupo_id = ?
  `),
  
  // ========== AUDITORIA ==========
  logCommand: db.prepare(`
    INSERT INTO auditoria 
    (usuario_id, grupo_id, comando, argumentos, sucesso, erro) 
    VALUES (?, ?, ?, ?, ?, ?)
  `),
  
  getCommandHistory: db.prepare(`
    SELECT * FROM auditoria 
    WHERE usuario_id = ? 
    ORDER BY timestamp DESC 
    LIMIT ?
  `),
  
  // ========== LIMPEZA E MANUTENÃ‡ÃƒO ==========
  cleanExpiredSilenced: db.prepare(`
    DELETE FROM silenciados 
    WHERE expires_at IS NOT NULL AND expires_at <= datetime('now')
  `),
  
  cleanOldAuditoria: db.prepare(`
    DELETE FROM auditoria 
    WHERE timestamp < ?
  `)
};

// ===== FUNÃ‡Ã•ES DE PERFORMANCE E DIAGNÃ“STICO =====

/**
 * Executa teste de performance do banco
 * Verifica se as operaÃ§Ãµes estÃ£o rÃ¡pidas
 */
function runPerformanceTest() {
  logger.info('ðŸ” Executando teste de performance...');
  
  const start = process.hrtime.bigint();
  
  try {
    // Teste de INSERT
    const testId = `test_${Date.now()}@c.us`;
    statements.insertUser.run(testId, 'Test User', '5519999999999');
    
    // Teste de SELECT
    const user = statements.getUser.get(testId);
    
    // Teste de consulta de admin (mais comum)
    statements.isGroupAdmin.get('test@g.us', testId);
    
    // Cleanup
    db.prepare('DELETE FROM usuarios WHERE id = ?').run(testId);
    
    const end = process.hrtime.bigint();
    const duration = Number(end - start) / 1000000; // ms
    
    logger.success(`âœ… Performance: ${duration.toFixed(2)}ms`);
    
    if (duration > 50) {
      logger.warn('âš ï¸ Performance degradada - verifique sistema');
    } else {
      logger.success('ðŸš€ Performance excelente!');
    }
    
    return { duration: duration.toFixed(2), status: duration > 50 ? 'slow' : 'fast' };
    
  } catch (error) {
    logger.error('âŒ Erro no teste:', error.message);
    return { duration: 'error', status: 'error' };
  }
}

/**
 * Configura jobs de limpeza automÃ¡tica
 * Remove dados antigos para manter performance
 */
function setupAutomaticCleanup() {
  logger.info('ðŸ§¹ Configurando limpeza automÃ¡tica...');
  
  // Limpeza de silenciamentos expirados (a cada hora)
  setInterval(() => {
    try {
      const result = statements.cleanExpiredSilenced.run();
      if (result.changes > 0) {
        logger.info(`ðŸ§¹ ${result.changes} silenciamentos expirados removidos`);
      }
    } catch (error) {
      logger.error('âŒ Erro na limpeza de silenciamentos:', error.message);
    }
  }, 60 * 60 * 1000); // 1 hora
  
  // Limpeza de auditoria antiga (a cada 24 horas - manter 30 dias)
  setInterval(() => {
    try {
      const cutoff = new Date();
      cutoff.setDate(cutoff.getDate() - 30);
      
      const result = statements.cleanOldAuditoria.run(cutoff.toISOString());
      if (result.changes > 0) {
        logger.info(`ðŸ§¹ ${result.changes} registros de auditoria antigos removidos`);
      }
    } catch (error) {
      logger.error('âŒ Erro na limpeza de auditoria:', error.message);
    }
  }, 24 * 60 * 60 * 1000); // 24 horas
  
  // OtimizaÃ§Ã£o automÃ¡tica do banco (a cada 6 horas)
  setInterval(() => {
    try {
      db.pragma('optimize');
      logger.info('ðŸš€ Banco otimizado automaticamente');
    } catch (error) {
      logger.error('âŒ Erro na otimizaÃ§Ã£o:', error.message);
    }
  }, 6 * 60 * 60 * 1000); // 6 horas
}

/**
 * ObtÃ©m estatÃ­sticas do banco
 */
function getDatabaseStats() {
  try {
    const stats = {};
    
    // Contadores de tabelas
    stats.usuarios = db.prepare('SELECT COUNT(*) as count FROM usuarios').get().count;
    stats.grupos = db.prepare('SELECT COUNT(*) as count FROM grupos').get().count;
    stats.admins = db.prepare('SELECT COUNT(*) as count FROM admins_grupos').get().count;
    stats.apelidos = db.prepare('SELECT COUNT(*) as count FROM apelidos').get().count;
    stats.silenciados = db.prepare('SELECT COUNT(*) as count FROM silenciados WHERE expires_at IS NULL OR expires_at > datetime("now")').get().count;
    stats.auditoria = db.prepare('SELECT COUNT(*) as count FROM auditoria').get().count;
    
    // Tamanho do banco
    const size = fs.statSync(DB_PATH).size;
    stats.tamanho = `${(size / 1024 / 1024).toFixed(2)} MB`;
    
    // Performance info
    const pragmas = {
      journal_mode: db.pragma('journal_mode', { simple: true }),
      cache_size: db.pragma('cache_size', { simple: true }),
      synchronous: db.pragma('synchronous', { simple: true })
    };
    stats.config = pragmas;
    
    return stats;
    
  } catch (error) {
    logger.error('âŒ Erro ao obter estatÃ­sticas:', error.message);
    return null;
  }
}

// ===== INICIALIZAÃ‡ÃƒO COMPLETA =====

// 1. Executar migrations
runMigrations();

// 2. Criar Ã­ndices
createOptimizedIndexes();

// 3. Aplicar otimizaÃ§Ã£o final
try {
  db.pragma('optimize');
  logger.success('âœ… OtimizaÃ§Ã£o final aplicada');
} catch (error) {
  logger.warn('âš ï¸ OtimizaÃ§Ã£o final falhou:', error.message);
}

// 4. Executar teste de performance
setTimeout(() => {
  runPerformanceTest();
}, 1000);

// 5. Configurar limpeza automÃ¡tica
setupAutomaticCleanup();

logger.success('ðŸŽ¯ Database SQLite completamente otimizado e pronto!');

// ===== EXPORTAÃ‡Ã•ES =====
module.exports = {
  db,
  statements,
  runPerformanceTest,
  setupAutomaticCleanup,
  getDatabaseStats
};
